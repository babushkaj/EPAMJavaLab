1. Develop a query to calculate the number of news, written by each author, the average number of comments per news for a current author and the most popular tag, referred to author news. All these information must be output in one single result set. Based on these query create a custom db view.
____________________________________________________________________________________________________________________

CREATE VIEW authors_with_number_of_their_news_and_most_popular_tag_id
AS
SELECT author.id AS author_id, author.name AS author_name,  author.surname AS author_surname, COUNT(news_author.news_id) AS news_count, 
(
	SELECT news_tag.tag_id
	FROM news_tag
	WHERE news_tag.news_id IN 
		(SELECT news_author.news_id 
		FROM news_author
		WHERE news_author.author_id = author.id)
	GROUP BY news_tag.tag_id
	HAVING COUNT(news_tag.tag_id) = (SELECT MAX(tag_count) 
									FROM (
										SELECT news_tag.tag_id, COUNT(news_tag.tag_id) AS tag_count
										FROM news_tag
										WHERE news_tag.news_id IN
											(SELECT news_author.news_id 
											FROM news_author
											WHERE news_author.author_id = author.id)
										GROUP BY news_tag.tag_id
									) AS max_tag_count)
	LIMIT 1
) AS most_popular_tag_id
FROM author
INNER JOIN news_author
ON author.id = news_author.author_id
GROUP BY author.id
____________________________________________________________________________________________________________________

2. Write SQL statement to select author names who wrote more than 3 000 characters, but the average number of characters per news is more than 500. Think about the shortest statement notation.
____________________________________________________________________________________________________________________

SELECT  author.name, COUNT(*)
FROM author 
INNER JOIN news_author
ON author.id = news_author.author_id
INNER JOIN news 
ON news.id = news_author.news_id
GROUP BY author_id, author.name
HAVING SUM(LENGTH(news.full_text))/COUNT(*) > 500 AND SUM(LENGTH(news.full_text)) > 3000
____________________________________________________________________________________________________________________

3. Create custom db function that will return the list of all tags referred to a current news, concatenated by specified separator character. Function must accept the news id and separator character as input parameters and return a single string as a result of tag values concatenation.
____________________________________________________________________________________________________________________

CREATE FUNCTION tags_concatenation(exact_news_id BIGINT, sep CHAR) RETURNS VARCHAR AS $$

SELECT ARRAY_TO_STRING(ARRAY_AGG(tag.name), sep)
FROM tag 
INNER JOIN news_tag
ON tag.id = news_tag.tag_id
WHERE news_tag.news_id = exact_news_id
GROUP BY news_tag.news_id

$$ LANGUAGE SQL;

SELECT tags_concatenation(1, '#');

//with cursor

CREATE OR REPLACE FUNCTION get_tags(newsid INTEGER, split char)
   RETURNS text AS $$
DECLARE 
   titles TEXT DEFAULT '';
   rec_tags   RECORD;
   cur_tags CURSOR(newsid INTEGER) 
     FOR SELECT tag.name
     FROM tag left join news_tag on tag.id = news_tag.tag_id
     WHERE news_tag.news_id = newsid;
BEGIN
   OPEN cur_tags(newsid);
    LOOP
      FETCH cur_tags INTO rec_tags;
  
      EXIT WHEN NOT FOUND;
         titles := titles ||split || rec_tags.name;
   END LOOP;
   CLOSE cur_tags;
   RETURN titles;
END; $$
LANGUAGE plpgsql;
____________________________________________________________________________________________________________________

4. Develop single SQL statement that will return the list of all available news (news id, news title columns) and one more column that will display all concatenated tags values, available for current news as a single string.
Make two versions of statement:
	a. By using previously developed custom function (#3).
	b. * By using Oracle 10g DB features.
____________________________________________________________________________________________________________________

SELECT news.id, news.title, tag_concatenation(news.id, '#')
FROM news
____________________________________________________________________________________________________________________

5. * Make a writers competition cross-map. Create a statement that will generate random authors distribution by competition pairs.
Statement will generate a list of author names pairs selected for a single round of tournament, displayed as two separate columns. Each author must be presented in resulting set (in both columns) once only. (The total number of authors must be even. Do not use custom functions during current implementation.)
____________________________________________________________________________________________________________________

SELECT column1.name, column2.name
FROM
    (SELECT ROW_NUMBER() OVER (ORDER BY RANDOM()) AS id, name
    FROM
        (SELECT name
        FROM author
        ORDER BY id
        LIMIT (SELECT COUNT(*)
                FROM author) / 2) AS authors
   ) AS column1,
    (SELECT ROW_NUMBER() OVER (ORDER BY RANDOM()) AS id, name
    FROM
        (SELECT name
        FROM author
        ORDER BY id
        DESC LIMIT (SELECT COUNT(*)
                FROM author) / 2) AS authors
    ) AS column2
WHERE column1.id = column2.id
____________________________________________________________________________________________________________________

6. Create custom LOGGING db table. The following corresponding columns must be created:
	a. Record insert date;
	b. Referenced Table Name - Table Name where new record was inserted;
	c. Description - The list of key-value pairs, separated by semicolon. Note: empty values and their column names must be omitted.
Add required changes to your DB Schema to populate current table columns each time when new record was inserted to any db table (in a scope of your schema).
____________________________________________________________________________________________________________________

CREATE TABLE logging (
	id BIGSERIAL PRIMARY KEY,
	insertion_date DATE NOT NULL,
	table_name NAME NOT NULL,
	inserted_data VARCHAR(3000) NOT NULL);

CREATE OR REPLACE FUNCTION author_insertion_log() RETURNS TRIGGER AS $BODY$
	BEGIN
		INSERT INTO logging (insertion_date, table_name, inserted_data) 
		VALUES (NOW(), TG_TABLE_NAME, CONCAT('id-', NEW.id, '; name-', NEW.name, '; surname-', NEW.surname)); 
		RETURN NEW;
	END;
$BODY$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER before_authors_insertion
BEFORE INSERT ON author
FOR EACH ROW
EXECUTE PROCEDURE author_insertion_log();

CREATE OR REPLACE FUNCTION news_insertion_log() RETURNS TRIGGER AS $BODY$
	BEGIN
		INSERT INTO logging (insertion_date, table_name, inserted_data) 
		VALUES (NOW(), TG_TABLE_NAME, CONCAT('id-', NEW.id, '; title-', NEW.title, '; short_text-', NEW.short_text,
		'; full_text-', NEW.full_text, '; creation_date-', NEW.creation_date, '; modification_date-', NEW.modification_date)); 
		RETURN NEW;
	END;
$BODY$ LANGUAGE plpgsql;

CREATE TRIGGER before_news_insertion
BEFORE INSERT ON news
FOR EACH ROW
EXECUTE PROCEDURE news_insertion_log();

CREATE OR REPLACE FUNCTION tags_insertion_log() RETURNS TRIGGER AS $BODY$
	BEGIN
		INSERT INTO logging (insertion_date, table_name, inserted_data) 
		VALUES (NOW(), TG_TABLE_NAME, CONCAT('id-', NEW.id, '; name-', NEW.name)); 
		RETURN NEW;
	END;
$BODY$ LANGUAGE plpgsql;

CREATE TRIGGER before_tags_insertion
BEFORE INSERT ON tag
FOR EACH ROW
EXECUTE PROCEDURE tags_insertion_log();

CREATE OR REPLACE FUNCTION users_insertion_log() RETURNS TRIGGER AS $BODY$
	BEGIN
		INSERT INTO logging (insertion_date, table_name, inserted_data) 
		VALUES (NOW(), TG_TABLE_NAME, CONCAT('id-', NEW.id, '; name-', NEW.name, '; surname-', NEW.surname, '; login-', NEW.login, '; password-', NEW.password)); 
		RETURN NEW;
	END;
$BODY$ LANGUAGE plpgsql;

CREATE TRIGGER before_users_insertion
BEFORE INSERT ON users
FOR EACH ROW
EXECUTE PROCEDURE users_insertion_log();
____________________________________________________________________________________________________________________

7. Prepare a SQL statement to output total/available space within each tablespace. Calculate “Used %” column value.
____________________________________________________________________________________________________________________

This query is impossible for POSTGRESQL, because this RDBMS has no limit for each tablespace (this limit equals free disc space on your computer).

For Oracle:

SELECT dba_free_space.tablespace_name, SUM(dba_data_files.bytes)/1024/1024 TOTAL_MB, SUM(dba_free_space.bytes)/1024/1024 FREE_MB,  
ROUND((SUM(dba_data_files.bytes)-SUM(dba_free_space.bytes))/SUM(dba_data_files.bytes), 3) USED_PERCENT_MB
FROM dba_free_space INNER JOIN dba_data_files
ON dba_free_space.tablespace_name = dba_data_files.tablespace_name
GROUP BY dba_free_space.tablespace_name;
____________________________________________________________________________________________________________________

8. Prepare a SQL Statement to calculate each table size in your schema.
____________________________________________________________________________________________________________________

SELECT nspname || '.' || relname AS table_name,
	pg_size_pretty(pg_total_relation_size(C.oid)) AS table_size
FROM pg_class C
LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
WHERE nspname NOT IN ('pg_catalog', 'information_schema')
AND C.relkind = 'r'
ORDER BY pg_total_relation_size(C.oid) DESC